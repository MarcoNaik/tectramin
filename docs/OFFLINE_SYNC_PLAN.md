# Offline Sync Implementation Plan

## Overview

Add offline-first capability to the native app using **expo-sqlite + Drizzle ORM** as local database, with a persistent sync queue that survives app restarts. Convex remains the server backend.

**Key Decisions:**
- Mobile app is a **data capture tool** (create/update only, no delete)
- Conflict resolution: **Mobile-always-wins** (field data is authoritative)
- Initial online sync **required** before offline capability
- SQLite is **single source of truth** for UI reads
- Architecture designed for **20+ tables** expansion
- No attachment support (for now)
- Start with tasks table only

## Use Case

| Aspect | Requirement |
|--------|-------------|
| Mobile Role | Offline data capture (create/update only) |
| Web Role | Full CRUD, but mobile overwrites on conflict |
| Online Writes | Convex direct → sync back to SQLite |
| Offline Writes | SQLite → queue → push on reconnect |
| First Launch | Requires initial online sync |
| UI Feedback | Minimal sync status icon |
| Offline Duration | Hours to days |

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     ALWAYS (UI READS)                       │
│           UI Components ──> SQLite (local truth)            │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                      ONLINE MODE                            │
│  Write: UI ──> Convex (direct) ──> Sync back to SQLite      │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     OFFLINE MODE                            │
│  Write: UI ──> SQLite ──> SyncQueue (pending operations)    │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                    ON RECONNECT                             │
│  1. Push: SyncQueue ──> Convex (mobile wins)                │
│  2. Pull: Convex ──> SQLite (update local cache)            │
└─────────────────────────────────────────────────────────────┘
```

- SQLite is the single source of truth for UI reads
- All writes check network status first
- When online: write to Convex, then sync result back to SQLite
- When offline: write to SQLite, queue operation for later sync
- Sync service pushes queue to Convex when online
- Pull from Convex updates local SQLite cache

## Dependencies to Install

```bash
cd apps/native
npm install expo-sqlite drizzle-orm @react-native-community/netinfo uuid
npm install -D drizzle-kit @types/uuid
```

## Files to Create

### Database Layer (`apps/native/src/db/`)
| File | Purpose |
|------|---------|
| `schema.ts` | Drizzle schema (tasks, syncQueue, syncMetadata) |
| `client.ts` | SQLite initialization with expo-sqlite |
| `migrations/` | Generated by drizzle-kit |

### Sync Layer (`apps/native/src/sync/`)
| File | Purpose |
|------|---------|
| `SyncService.ts` | Orchestrates push/pull operations |
| `SyncQueue.ts` | Manages persistent operation queue |
| `SyncPush.ts` | Pushes local changes to Convex |
| `SyncPull.ts` | Pulls server changes to SQLite |
| `NetworkMonitor.ts` | NetInfo connectivity detection |
| `types.ts` | Shared TypeScript types |
| `TableRegistry.ts` | Generic table registration for 20+ tables |

### Hooks (`apps/native/src/hooks/`)
| File | Purpose |
|------|---------|
| `useDatabase.ts` | Database access hook |
| `useTasks.ts` | Replaces Convex useQuery/useMutation |
| `useSyncStatus.ts` | Sync state (pending count, last sync) |
| `useNetworkStatus.ts` | Online/offline state |
| `useOfflineFirst.ts` | Generic hook factory for any table |

### Providers (`apps/native/src/providers/`)
| File | Purpose |
|------|---------|
| `DatabaseProvider.tsx` | Database context + migrations |
| `SyncProvider.tsx` | Sync service context |
| `OfflineProvider.tsx` | Combined wrapper |

### Convex (`packages/backend/convex/`)
| File | Purpose |
|------|---------|
| `sync.ts` | New - upsertTask, getChangesSince, bulkUpsert |

## Files to Modify

| File | Changes |
|------|---------|
| `apps/native/package.json` | Add dependencies |
| `apps/native/metro.config.js` | Add `.sql` to sourceExts |
| `apps/native/app.json` | Add expo-sqlite plugin |
| `apps/native/App.tsx` | Wrap with OfflineProvider |
| `apps/native/src/screens/HomeScreen.tsx` | Use local hooks |
| `packages/backend/convex/schema.ts` | Add clientId, timestamps, indexes |
| `packages/backend/convex/tasks.ts` | Update for sync support |

## Schema Design

### Drizzle (SQLite) - `apps/native/src/db/schema.ts`

```typescript
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";

export const tasks = sqliteTable("tasks", {
  clientId: text("client_id").primaryKey(),
  serverId: text("server_id"),
  text: text("text").notNull(),
  isCompleted: integer("is_completed", { mode: "boolean" }).notNull().default(false),
  userId: text("user_id").notNull(),
  createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
  updatedAt: integer("updated_at", { mode: "timestamp" }).notNull(),
  syncStatus: text("sync_status", { enum: ["pending", "synced"] }).default("synced"),
});

export const syncQueue = sqliteTable("sync_queue", {
  id: text("id").primaryKey(),
  tableName: text("table_name").notNull(),
  operation: text("operation", { enum: ["create", "update"] }).notNull(),
  recordClientId: text("record_client_id").notNull(),
  payload: text("payload").notNull(),
  createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
  retryCount: integer("retry_count").default(0),
});

export const syncMetadata = sqliteTable("sync_metadata", {
  id: text("id").primaryKey(),
  tableName: text("table_name").notNull().unique(),
  lastSyncTimestamp: integer("last_sync_timestamp", { mode: "timestamp" }),
  initialSyncComplete: integer("initial_sync_complete", { mode: "boolean" }).default(false),
});
```

### Convex Schema Update - `packages/backend/convex/schema.ts`

```typescript
tasks: defineTable({
  clientId: v.string(),
  text: v.string(),
  isCompleted: v.boolean(),
  userId: v.string(),
  createdAt: v.number(),
  updatedAt: v.number(),
})
  .index("by_user", ["userId"])
  .index("by_client_id", ["clientId"])
  .index("by_user_and_updated", ["userId", "updatedAt"])
```

## Sync Flow

### Initial Sync (First Login - Required)

```
1. User logs in successfully
        │
        v
2. Check syncMetadata.initialSyncComplete for each table
        │
        v
3. For tables not synced:
   - Query Convex: getAllForUser(userId)
   - Bulk insert to SQLite
   - Set initialSyncComplete = true
        │
        v
4. App ready for use (online or offline)
```

### Push Flow (Reconnect)

```
1. TRIGGER (network restored / app resume)
        │
        v
2. PUSH PHASE
   - Read sync_queue ordered by createdAt
   - For each operation:
     - Call Convex upsert mutation
     - On success: remove from queue, update serverId, set syncStatus = "synced"
     - On failure: increment retryCount (max 3, then surface error)
        │
        v
3. COMPLETE - Queue empty
```

### Pull Flow (Background Refresh)

```
1. TRIGGER (after push complete / periodic / manual)
        │
        v
2. PULL PHASE
   - Query Convex: getChangesSince(lastSyncTimestamp, userId)
   - For each server record:
     - If local syncStatus = "pending": SKIP (mobile wins)
     - Otherwise: upsert to SQLite
   - Update syncMetadata.lastSyncTimestamp
        │
        v
3. COMPLETE - UI refreshes via useLiveQuery
```

### Write Flow (Online vs Offline)

```
USER INITIATES WRITE (create/update)
        │
        v
CHECK NETWORK STATUS
        │
        ├──> ONLINE
        │      │
        │      v
        │    Call Convex mutation directly
        │      │
        │      v
        │    On success: update SQLite with server response
        │    On failure: fall back to offline flow
        │
        └──> OFFLINE
               │
               v
             Write to SQLite (syncStatus = "pending")
               │
               v
             Add operation to syncQueue
               │
               v
             UI updates immediately via useLiveQuery
```

## Config Changes

### metro.config.js
```javascript
config.resolver.sourceExts.push("sql");
```

### app.json
```json
{
  "expo": {
    "plugins": ["expo-font", "expo-secure-store", ["expo-sqlite"]]
  }
}
```

### drizzle.config.ts (new)
```typescript
export default {
  schema: "./src/db/schema.ts",
  out: "./src/db/migrations",
  dialect: "sqlite",
  driver: "expo",
};
```

## Implementation Order

### Phase 1: Foundation
1. Install dependencies
2. Update metro.config.js, app.json
3. Create drizzle.config.ts
4. Create schema.ts
5. Generate migration: `npx drizzle-kit generate`
6. Create client.ts

### Phase 2: Database Layer
7. Create DatabaseProvider.tsx
8. Create useDatabase.ts hook
9. Create types.ts
10. Create TableRegistry.ts (generic table registration)

### Phase 3: Sync Infrastructure
11. Create NetworkMonitor.ts
12. Create SyncQueue.ts
13. Create SyncPush.ts
14. Create SyncPull.ts
15. Create SyncService.ts

### Phase 4: Convex Backend
16. Update schema.ts (add clientId, timestamps, indexes)
17. Create sync.ts (upsertTask, getChangesSince, getAllForUser)
18. Run `npx convex dev`

### Phase 5: Hooks & Providers
19. Create useSyncStatus.ts
20. Create useNetworkStatus.ts
21. Create useOfflineFirst.ts (generic hook factory)
22. Create useTasks.ts (using useOfflineFirst)
23. Create SyncProvider.tsx
24. Create OfflineProvider.tsx

### Phase 6: UI Integration
25. Update App.tsx (wrap with OfflineProvider)
26. Update HomeScreen.tsx (use local hooks, remove delete button)
27. Add sync status icon to header

## Key Design Decisions

| Decision | Rationale |
|----------|-----------|
| Client-generated UUIDs | Enables offline creates with stable IDs |
| No delete on mobile | Simplifies sync, prevents accidental data loss |
| Mobile-always-wins | Field data is authoritative over web edits |
| Initial sync required | Ensures complete offline capability from start |
| SQLite for reads | Seamless offline experience, no loading states |
| Generic TableRegistry | Scales to 20+ tables without code duplication |
| Drizzle useLiveQuery | Reactive UI updates without manual refresh |

## Adding New Tables (Expansion)

1. Add table to `schema.ts` with standard fields:
   - `clientId` (primary key)
   - `serverId` (nullable, assigned after first sync)
   - `userId` (for user scoping)
   - `createdAt`, `updatedAt` (timestamps)
   - `syncStatus` (pending/synced)

2. Run `npx drizzle-kit generate`

3. Add to Convex schema with matching indexes:
   - `by_client_id`
   - `by_user`
   - `by_user_and_updated`

4. Create sync functions in `sync.ts`:
   - `upsert[TableName]`
   - `get[TableName]ChangesSince`
   - `getAll[TableName]ForUser`

5. Register in TableRegistry:
   ```typescript
   tableRegistry.register({
     name: "newTable",
     localSchema: newTableSchema,
     convexUpsert: api.sync.upsertNewTable,
     convexGetChanges: api.sync.getNewTableChangesSince,
     convexGetAll: api.sync.getAllNewTableForUser,
   });
   ```

6. Create hook using factory:
   ```typescript
   export const useNewTable = createOfflineHook("newTable");
   ```

## Error Handling

| Scenario | Handling |
|----------|----------|
| Network lost mid-sync | Queue remaining ops, resume on reconnect |
| Convex mutation fails | Retry up to 3 times, then mark as failed |
| Initial sync fails | Block app usage, show retry button |
| Conflict during pull | Skip (mobile wins via pending status) |

## UI Components Needed

- `SyncStatusIcon` - Shows online/offline/syncing state
- `InitialSyncScreen` - Loading screen during first sync
- `SyncErrorBanner` - Shows when sync operations fail

## Sources

- [Expo SQLite Documentation](https://docs.expo.dev/versions/latest/sdk/sqlite/)
- [Drizzle ORM Expo Setup](https://orm.drizzle.team/docs/get-started/expo-new)
- [Drizzle useLiveQuery](https://orm.drizzle.team/docs/connect-expo-sqlite)
- [Expo Local-First Guide](https://docs.expo.dev/guides/local-first/)
- [Convex Sync Patterns](https://stack.convex.dev/sync)
